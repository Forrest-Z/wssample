# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from displaydata_msgs/DisplayData.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct

import std_msgs.msg

class DisplayData(genpy.Message):
  _md5sum = "4ffa05f2036a9bdc4fea667a8a91fa8a"
  _type = "displaydata_msgs/DisplayData"
  _has_header = True  # flag to mark the presence of a Header object
  _full_text = """Header header

# RTK state
# -1 : no gnss
# 0 : 2D or 3D gnss fix
# 1 : SBAS or Starfire gnss fix
# 2 : Diff or rtk fix
int32 rtk_state 

float64 lat
float64 lng
float64 alt

# enu coord
float64 x_enu
float64 y_enu
float64 z_enu
float64 xy_std_enu

#GPS HEADING 
float64 heading_angle

# number of satellite
int32 NumSate

# kalman velocity
float64 vx

# Tli65 vehicle can_rx
int32 auto_mode
float64 current_steer
float64 current_brake_pedal_pos
int32 current_throttle_percentage
int32 current_retarder_torque_percentage
int32 current_EPB
int32 current_gear
int32 current_hang_angle

int32 air_pressure1
int32 air_pressure2

int32 left_light
int32 right_light
int32 near_light
int32 far_light
int32 air_beep
int32 top_warning_light
int32 front_fog_light
int32 front_work_light
int32 side_light
int32 position_light
int32 back_left_light
int32 back_right_light
int32 back_position_light
int32 brake_light
int32 reverse_light
int32 back_work_light
int32 fuel_consumption

# planner waypoints
string planner_fsm_state
int32 lock_down_index
int32[] pt_index
float64[] wpt_x
float64[] wpt_y

# control
string control_fsm_state
float64 control_steer
int32 control_throttle_percentage
float64 control_xbr
int32 control_EPB
string control_gear
string control_hang
 
# ft1
int32 engine_fault
int32 gear_fault
int32 EBS_fault
int32 EPS_fault
int32 EPB_fault

# tyre
int32 tyre_pressure_leftfront
int32 tyre_pressure_rightfront
float64 front_left_temperature
float64 front_right_temperature
================================================================================
MSG: std_msgs/Header
# Standard metadata for higher-level stamped data types.
# This is generally used to communicate timestamped data 
# in a particular coordinate frame.
# 
# sequence ID: consecutively increasing ID 
uint32 seq
#Two-integer timestamp that is expressed as:
# * stamp.sec: seconds (stamp_secs) since epoch (in Python the variable is called 'secs')
# * stamp.nsec: nanoseconds since stamp_secs (in Python the variable is called 'nsecs')
# time-handling sugar is provided by the client library
time stamp
#Frame this data is associated with
# 0: no frame
# 1: global frame
string frame_id
"""
  __slots__ = ['header','rtk_state','lat','lng','alt','x_enu','y_enu','z_enu','xy_std_enu','heading_angle','NumSate','vx','auto_mode','current_steer','current_brake_pedal_pos','current_throttle_percentage','current_retarder_torque_percentage','current_EPB','current_gear','current_hang_angle','air_pressure1','air_pressure2','left_light','right_light','near_light','far_light','air_beep','top_warning_light','front_fog_light','front_work_light','side_light','position_light','back_left_light','back_right_light','back_position_light','brake_light','reverse_light','back_work_light','fuel_consumption','planner_fsm_state','lock_down_index','pt_index','wpt_x','wpt_y','control_fsm_state','control_steer','control_throttle_percentage','control_xbr','control_EPB','control_gear','control_hang','engine_fault','gear_fault','EBS_fault','EPS_fault','EPB_fault','tyre_pressure_leftfront','tyre_pressure_rightfront','front_left_temperature','front_right_temperature']
  _slot_types = ['std_msgs/Header','int32','float64','float64','float64','float64','float64','float64','float64','float64','int32','float64','int32','float64','float64','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','int32','string','int32','int32[]','float64[]','float64[]','string','float64','int32','float64','int32','string','string','int32','int32','int32','int32','int32','int32','int32','float64','float64']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       header,rtk_state,lat,lng,alt,x_enu,y_enu,z_enu,xy_std_enu,heading_angle,NumSate,vx,auto_mode,current_steer,current_brake_pedal_pos,current_throttle_percentage,current_retarder_torque_percentage,current_EPB,current_gear,current_hang_angle,air_pressure1,air_pressure2,left_light,right_light,near_light,far_light,air_beep,top_warning_light,front_fog_light,front_work_light,side_light,position_light,back_left_light,back_right_light,back_position_light,brake_light,reverse_light,back_work_light,fuel_consumption,planner_fsm_state,lock_down_index,pt_index,wpt_x,wpt_y,control_fsm_state,control_steer,control_throttle_percentage,control_xbr,control_EPB,control_gear,control_hang,engine_fault,gear_fault,EBS_fault,EPS_fault,EPB_fault,tyre_pressure_leftfront,tyre_pressure_rightfront,front_left_temperature,front_right_temperature

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(DisplayData, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.header is None:
        self.header = std_msgs.msg.Header()
      if self.rtk_state is None:
        self.rtk_state = 0
      if self.lat is None:
        self.lat = 0.
      if self.lng is None:
        self.lng = 0.
      if self.alt is None:
        self.alt = 0.
      if self.x_enu is None:
        self.x_enu = 0.
      if self.y_enu is None:
        self.y_enu = 0.
      if self.z_enu is None:
        self.z_enu = 0.
      if self.xy_std_enu is None:
        self.xy_std_enu = 0.
      if self.heading_angle is None:
        self.heading_angle = 0.
      if self.NumSate is None:
        self.NumSate = 0
      if self.vx is None:
        self.vx = 0.
      if self.auto_mode is None:
        self.auto_mode = 0
      if self.current_steer is None:
        self.current_steer = 0.
      if self.current_brake_pedal_pos is None:
        self.current_brake_pedal_pos = 0.
      if self.current_throttle_percentage is None:
        self.current_throttle_percentage = 0
      if self.current_retarder_torque_percentage is None:
        self.current_retarder_torque_percentage = 0
      if self.current_EPB is None:
        self.current_EPB = 0
      if self.current_gear is None:
        self.current_gear = 0
      if self.current_hang_angle is None:
        self.current_hang_angle = 0
      if self.air_pressure1 is None:
        self.air_pressure1 = 0
      if self.air_pressure2 is None:
        self.air_pressure2 = 0
      if self.left_light is None:
        self.left_light = 0
      if self.right_light is None:
        self.right_light = 0
      if self.near_light is None:
        self.near_light = 0
      if self.far_light is None:
        self.far_light = 0
      if self.air_beep is None:
        self.air_beep = 0
      if self.top_warning_light is None:
        self.top_warning_light = 0
      if self.front_fog_light is None:
        self.front_fog_light = 0
      if self.front_work_light is None:
        self.front_work_light = 0
      if self.side_light is None:
        self.side_light = 0
      if self.position_light is None:
        self.position_light = 0
      if self.back_left_light is None:
        self.back_left_light = 0
      if self.back_right_light is None:
        self.back_right_light = 0
      if self.back_position_light is None:
        self.back_position_light = 0
      if self.brake_light is None:
        self.brake_light = 0
      if self.reverse_light is None:
        self.reverse_light = 0
      if self.back_work_light is None:
        self.back_work_light = 0
      if self.fuel_consumption is None:
        self.fuel_consumption = 0
      if self.planner_fsm_state is None:
        self.planner_fsm_state = ''
      if self.lock_down_index is None:
        self.lock_down_index = 0
      if self.pt_index is None:
        self.pt_index = []
      if self.wpt_x is None:
        self.wpt_x = []
      if self.wpt_y is None:
        self.wpt_y = []
      if self.control_fsm_state is None:
        self.control_fsm_state = ''
      if self.control_steer is None:
        self.control_steer = 0.
      if self.control_throttle_percentage is None:
        self.control_throttle_percentage = 0
      if self.control_xbr is None:
        self.control_xbr = 0.
      if self.control_EPB is None:
        self.control_EPB = 0
      if self.control_gear is None:
        self.control_gear = ''
      if self.control_hang is None:
        self.control_hang = ''
      if self.engine_fault is None:
        self.engine_fault = 0
      if self.gear_fault is None:
        self.gear_fault = 0
      if self.EBS_fault is None:
        self.EBS_fault = 0
      if self.EPS_fault is None:
        self.EPS_fault = 0
      if self.EPB_fault is None:
        self.EPB_fault = 0
      if self.tyre_pressure_leftfront is None:
        self.tyre_pressure_leftfront = 0
      if self.tyre_pressure_rightfront is None:
        self.tyre_pressure_rightfront = 0
      if self.front_left_temperature is None:
        self.front_left_temperature = 0.
      if self.front_right_temperature is None:
        self.front_right_temperature = 0.
    else:
      self.header = std_msgs.msg.Header()
      self.rtk_state = 0
      self.lat = 0.
      self.lng = 0.
      self.alt = 0.
      self.x_enu = 0.
      self.y_enu = 0.
      self.z_enu = 0.
      self.xy_std_enu = 0.
      self.heading_angle = 0.
      self.NumSate = 0
      self.vx = 0.
      self.auto_mode = 0
      self.current_steer = 0.
      self.current_brake_pedal_pos = 0.
      self.current_throttle_percentage = 0
      self.current_retarder_torque_percentage = 0
      self.current_EPB = 0
      self.current_gear = 0
      self.current_hang_angle = 0
      self.air_pressure1 = 0
      self.air_pressure2 = 0
      self.left_light = 0
      self.right_light = 0
      self.near_light = 0
      self.far_light = 0
      self.air_beep = 0
      self.top_warning_light = 0
      self.front_fog_light = 0
      self.front_work_light = 0
      self.side_light = 0
      self.position_light = 0
      self.back_left_light = 0
      self.back_right_light = 0
      self.back_position_light = 0
      self.brake_light = 0
      self.reverse_light = 0
      self.back_work_light = 0
      self.fuel_consumption = 0
      self.planner_fsm_state = ''
      self.lock_down_index = 0
      self.pt_index = []
      self.wpt_x = []
      self.wpt_y = []
      self.control_fsm_state = ''
      self.control_steer = 0.
      self.control_throttle_percentage = 0
      self.control_xbr = 0.
      self.control_EPB = 0
      self.control_gear = ''
      self.control_hang = ''
      self.engine_fault = 0
      self.gear_fault = 0
      self.EBS_fault = 0
      self.EPS_fault = 0
      self.EPB_fault = 0
      self.tyre_pressure_leftfront = 0
      self.tyre_pressure_rightfront = 0
      self.front_left_temperature = 0.
      self.front_right_temperature = 0.

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_i8didi2d24i().pack(_x.rtk_state, _x.lat, _x.lng, _x.alt, _x.x_enu, _x.y_enu, _x.z_enu, _x.xy_std_enu, _x.heading_angle, _x.NumSate, _x.vx, _x.auto_mode, _x.current_steer, _x.current_brake_pedal_pos, _x.current_throttle_percentage, _x.current_retarder_torque_percentage, _x.current_EPB, _x.current_gear, _x.current_hang_angle, _x.air_pressure1, _x.air_pressure2, _x.left_light, _x.right_light, _x.near_light, _x.far_light, _x.air_beep, _x.top_warning_light, _x.front_fog_light, _x.front_work_light, _x.side_light, _x.position_light, _x.back_left_light, _x.back_right_light, _x.back_position_light, _x.brake_light, _x.reverse_light, _x.back_work_light, _x.fuel_consumption))
      _x = self.planner_fsm_state
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.lock_down_index
      buff.write(_get_struct_i().pack(_x))
      length = len(self.pt_index)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(struct.Struct(pattern).pack(*self.pt_index))
      length = len(self.wpt_x)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.wpt_x))
      length = len(self.wpt_y)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(struct.Struct(pattern).pack(*self.wpt_y))
      _x = self.control_fsm_state
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_didi().pack(_x.control_steer, _x.control_throttle_percentage, _x.control_xbr, _x.control_EPB))
      _x = self.control_gear
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.control_hang
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_7i2d().pack(_x.engine_fault, _x.gear_fault, _x.EBS_fault, _x.EPS_fault, _x.EPB_fault, _x.tyre_pressure_leftfront, _x.tyre_pressure_rightfront, _x.front_left_temperature, _x.front_right_temperature))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 196
      (_x.rtk_state, _x.lat, _x.lng, _x.alt, _x.x_enu, _x.y_enu, _x.z_enu, _x.xy_std_enu, _x.heading_angle, _x.NumSate, _x.vx, _x.auto_mode, _x.current_steer, _x.current_brake_pedal_pos, _x.current_throttle_percentage, _x.current_retarder_torque_percentage, _x.current_EPB, _x.current_gear, _x.current_hang_angle, _x.air_pressure1, _x.air_pressure2, _x.left_light, _x.right_light, _x.near_light, _x.far_light, _x.air_beep, _x.top_warning_light, _x.front_fog_light, _x.front_work_light, _x.side_light, _x.position_light, _x.back_left_light, _x.back_right_light, _x.back_position_light, _x.brake_light, _x.reverse_light, _x.back_work_light, _x.fuel_consumption,) = _get_struct_i8didi2d24i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.planner_fsm_state = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.planner_fsm_state = str[start:end]
      start = end
      end += 4
      (self.lock_down_index,) = _get_struct_i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.pt_index = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.wpt_x = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.wpt_y = s.unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.control_fsm_state = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.control_fsm_state = str[start:end]
      _x = self
      start = end
      end += 24
      (_x.control_steer, _x.control_throttle_percentage, _x.control_xbr, _x.control_EPB,) = _get_struct_didi().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.control_gear = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.control_gear = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.control_hang = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.control_hang = str[start:end]
      _x = self
      start = end
      end += 44
      (_x.engine_fault, _x.gear_fault, _x.EBS_fault, _x.EPS_fault, _x.EPB_fault, _x.tyre_pressure_leftfront, _x.tyre_pressure_rightfront, _x.front_left_temperature, _x.front_right_temperature,) = _get_struct_7i2d().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_3I().pack(_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs))
      _x = self.header.frame_id
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_i8didi2d24i().pack(_x.rtk_state, _x.lat, _x.lng, _x.alt, _x.x_enu, _x.y_enu, _x.z_enu, _x.xy_std_enu, _x.heading_angle, _x.NumSate, _x.vx, _x.auto_mode, _x.current_steer, _x.current_brake_pedal_pos, _x.current_throttle_percentage, _x.current_retarder_torque_percentage, _x.current_EPB, _x.current_gear, _x.current_hang_angle, _x.air_pressure1, _x.air_pressure2, _x.left_light, _x.right_light, _x.near_light, _x.far_light, _x.air_beep, _x.top_warning_light, _x.front_fog_light, _x.front_work_light, _x.side_light, _x.position_light, _x.back_left_light, _x.back_right_light, _x.back_position_light, _x.brake_light, _x.reverse_light, _x.back_work_light, _x.fuel_consumption))
      _x = self.planner_fsm_state
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.lock_down_index
      buff.write(_get_struct_i().pack(_x))
      length = len(self.pt_index)
      buff.write(_struct_I.pack(length))
      pattern = '<%si'%length
      buff.write(self.pt_index.tostring())
      length = len(self.wpt_x)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.wpt_x.tostring())
      length = len(self.wpt_y)
      buff.write(_struct_I.pack(length))
      pattern = '<%sd'%length
      buff.write(self.wpt_y.tostring())
      _x = self.control_fsm_state
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_didi().pack(_x.control_steer, _x.control_throttle_percentage, _x.control_xbr, _x.control_EPB))
      _x = self.control_gear
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self.control_hang
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
      _x = self
      buff.write(_get_struct_7i2d().pack(_x.engine_fault, _x.gear_fault, _x.EBS_fault, _x.EPS_fault, _x.EPB_fault, _x.tyre_pressure_leftfront, _x.tyre_pressure_rightfront, _x.front_left_temperature, _x.front_right_temperature))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      if self.header is None:
        self.header = std_msgs.msg.Header()
      end = 0
      _x = self
      start = end
      end += 12
      (_x.header.seq, _x.header.stamp.secs, _x.header.stamp.nsecs,) = _get_struct_3I().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.header.frame_id = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.header.frame_id = str[start:end]
      _x = self
      start = end
      end += 196
      (_x.rtk_state, _x.lat, _x.lng, _x.alt, _x.x_enu, _x.y_enu, _x.z_enu, _x.xy_std_enu, _x.heading_angle, _x.NumSate, _x.vx, _x.auto_mode, _x.current_steer, _x.current_brake_pedal_pos, _x.current_throttle_percentage, _x.current_retarder_torque_percentage, _x.current_EPB, _x.current_gear, _x.current_hang_angle, _x.air_pressure1, _x.air_pressure2, _x.left_light, _x.right_light, _x.near_light, _x.far_light, _x.air_beep, _x.top_warning_light, _x.front_fog_light, _x.front_work_light, _x.side_light, _x.position_light, _x.back_left_light, _x.back_right_light, _x.back_position_light, _x.brake_light, _x.reverse_light, _x.back_work_light, _x.fuel_consumption,) = _get_struct_i8didi2d24i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.planner_fsm_state = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.planner_fsm_state = str[start:end]
      start = end
      end += 4
      (self.lock_down_index,) = _get_struct_i().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%si'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.pt_index = numpy.frombuffer(str[start:end], dtype=numpy.int32, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.wpt_x = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      pattern = '<%sd'%length
      start = end
      s = struct.Struct(pattern)
      end += s.size
      self.wpt_y = numpy.frombuffer(str[start:end], dtype=numpy.float64, count=length)
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.control_fsm_state = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.control_fsm_state = str[start:end]
      _x = self
      start = end
      end += 24
      (_x.control_steer, _x.control_throttle_percentage, _x.control_xbr, _x.control_EPB,) = _get_struct_didi().unpack(str[start:end])
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.control_gear = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.control_gear = str[start:end]
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.control_hang = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.control_hang = str[start:end]
      _x = self
      start = end
      end += 44
      (_x.engine_fault, _x.gear_fault, _x.EBS_fault, _x.EPS_fault, _x.EPB_fault, _x.tyre_pressure_leftfront, _x.tyre_pressure_rightfront, _x.front_left_temperature, _x.front_right_temperature,) = _get_struct_7i2d().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_3I = None
def _get_struct_3I():
    global _struct_3I
    if _struct_3I is None:
        _struct_3I = struct.Struct("<3I")
    return _struct_3I
_struct_7i2d = None
def _get_struct_7i2d():
    global _struct_7i2d
    if _struct_7i2d is None:
        _struct_7i2d = struct.Struct("<7i2d")
    return _struct_7i2d
_struct_didi = None
def _get_struct_didi():
    global _struct_didi
    if _struct_didi is None:
        _struct_didi = struct.Struct("<didi")
    return _struct_didi
_struct_i = None
def _get_struct_i():
    global _struct_i
    if _struct_i is None:
        _struct_i = struct.Struct("<i")
    return _struct_i
_struct_i8didi2d24i = None
def _get_struct_i8didi2d24i():
    global _struct_i8didi2d24i
    if _struct_i8didi2d24i is None:
        _struct_i8didi2d24i = struct.Struct("<i8didi2d24i")
    return _struct_i8didi2d24i
